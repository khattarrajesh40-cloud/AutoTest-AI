{"ast":null,"code":"import ENDPOINTS from \"./generated/endpoints.js\";\nconst endpointMethodsMap = /* @__PURE__ */new Map();\nfor (const [scope, endpoints] of Object.entries(ENDPOINTS)) {\n  for (const [methodName, endpoint] of Object.entries(endpoints)) {\n    const [route, defaults, decorations] = endpoint;\n    const [method, url] = route.split(/ /);\n    const endpointDefaults = Object.assign({\n      method,\n      url\n    }, defaults);\n    if (!endpointMethodsMap.has(scope)) {\n      endpointMethodsMap.set(scope, /* @__PURE__ */new Map());\n    }\n    endpointMethodsMap.get(scope).set(methodName, {\n      scope,\n      methodName,\n      endpointDefaults,\n      decorations\n    });\n  }\n}\nconst handler = {\n  has({\n    scope\n  }, methodName) {\n    return endpointMethodsMap.get(scope).has(methodName);\n  },\n  getOwnPropertyDescriptor(target, methodName) {\n    return {\n      value: this.get(target, methodName),\n      // ensures method is in the cache\n      configurable: true,\n      writable: true,\n      enumerable: true\n    };\n  },\n  defineProperty(target, methodName, descriptor) {\n    Object.defineProperty(target.cache, methodName, descriptor);\n    return true;\n  },\n  deleteProperty(target, methodName) {\n    delete target.cache[methodName];\n    return true;\n  },\n  ownKeys({\n    scope\n  }) {\n    return [...endpointMethodsMap.get(scope).keys()];\n  },\n  set(target, methodName, value) {\n    return target.cache[methodName] = value;\n  },\n  get({\n    octokit,\n    scope,\n    cache\n  }, methodName) {\n    if (cache[methodName]) {\n      return cache[methodName];\n    }\n    const method = endpointMethodsMap.get(scope).get(methodName);\n    if (!method) {\n      return void 0;\n    }\n    const {\n      endpointDefaults,\n      decorations\n    } = method;\n    if (decorations) {\n      cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);\n    } else {\n      cache[methodName] = octokit.request.defaults(endpointDefaults);\n    }\n    return cache[methodName];\n  }\n};\nfunction endpointsToMethods(octokit) {\n  const newMethods = {};\n  for (const scope of endpointMethodsMap.keys()) {\n    newMethods[scope] = new Proxy({\n      octokit,\n      scope,\n      cache: {}\n    }, handler);\n  }\n  return newMethods;\n}\nfunction decorate(octokit, scope, methodName, defaults, decorations) {\n  const requestWithDefaults = octokit.request.defaults(defaults);\n  function withDecorations(...args) {\n    let options = requestWithDefaults.endpoint.merge(...args);\n    if (decorations.mapToData) {\n      options = Object.assign({}, options, {\n        data: options[decorations.mapToData],\n        [decorations.mapToData]: void 0\n      });\n      return requestWithDefaults(options);\n    }\n    if (decorations.renamed) {\n      const [newScope, newMethodName] = decorations.renamed;\n      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);\n    }\n    if (decorations.deprecated) {\n      octokit.log.warn(decorations.deprecated);\n    }\n    if (decorations.renamedParameters) {\n      const options2 = requestWithDefaults.endpoint.merge(...args);\n      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {\n        if (name in options2) {\n          octokit.log.warn(`\"${name}\" parameter is deprecated for \"octokit.${scope}.${methodName}()\". Use \"${alias}\" instead`);\n          if (!(alias in options2)) {\n            options2[alias] = options2[name];\n          }\n          delete options2[name];\n        }\n      }\n      return requestWithDefaults(options2);\n    }\n    return requestWithDefaults(...args);\n  }\n  return Object.assign(withDecorations, requestWithDefaults);\n}\nexport { endpointsToMethods };","map":{"version":3,"names":["ENDPOINTS","endpointMethodsMap","Map","scope","endpoints","Object","entries","methodName","endpoint","route","defaults","decorations","method","url","split","endpointDefaults","assign","has","set","get","handler","getOwnPropertyDescriptor","target","value","configurable","writable","enumerable","defineProperty","descriptor","cache","deleteProperty","ownKeys","keys","octokit","decorate","request","endpointsToMethods","newMethods","Proxy","requestWithDefaults","withDecorations","args","options","merge","mapToData","data","renamed","newScope","newMethodName","log","warn","deprecated","renamedParameters","options2","name","alias"],"sources":["C:\\Users\\sharm\\OneDrive\\Desktop\\AI Based Test Case Generator\\node_modules\\@octokit\\src\\endpoints-to-methods.ts"],"sourcesContent":["import type { Octokit } from \"@octokit/core\";\nimport type { EndpointOptions, RequestParameters, Route } from \"@octokit/types\";\nimport ENDPOINTS from \"./generated/endpoints.js\";\nimport type { RestEndpointMethods } from \"./generated/method-types.js\";\nimport type { EndpointDecorations } from \"./types.js\";\n\n// The following code was refactored in: https://github.com/octokit/plugin-rest-endpoint-methods.js/pull/622\n// to optimise the runtime performance of Octokit initialization.\n//\n// This optimization involves two key changes:\n// 1. Pre-Computation: The endpoint methods are pre-computed once at module load\n//    time instead of each invocation of `endpointsToMethods()`.\n// 2. Lazy initialization and caching: We use a Proxy for each scope to only\n//    initialize methods that are actually called. This reduces runtime overhead\n//    as the initialization involves deep merging of objects. The initialized\n//    methods are then cached for future use.\n\nconst endpointMethodsMap = new Map();\nfor (const [scope, endpoints] of Object.entries(ENDPOINTS)) {\n  for (const [methodName, endpoint] of Object.entries(endpoints)) {\n    const [route, defaults, decorations] = endpoint;\n    const [method, url] = route.split(/ /);\n    const endpointDefaults = Object.assign(\n      {\n        method,\n        url,\n      },\n      defaults,\n    );\n\n    if (!endpointMethodsMap.has(scope)) {\n      endpointMethodsMap.set(scope, new Map());\n    }\n\n    endpointMethodsMap.get(scope).set(methodName, {\n      scope,\n      methodName,\n      endpointDefaults,\n      decorations,\n    });\n  }\n}\n\ntype ProxyTarget = {\n  octokit: Octokit;\n  scope: string;\n  cache: Record<string, (...args: any[]) => any>;\n};\n\nconst handler = {\n  has({ scope }: ProxyTarget, methodName: string) {\n    return endpointMethodsMap.get(scope).has(methodName);\n  },\n  getOwnPropertyDescriptor(target: ProxyTarget, methodName: string) {\n    return {\n      value: this.get(target, methodName), // ensures method is in the cache\n      configurable: true,\n      writable: true,\n      enumerable: true,\n    };\n  },\n  defineProperty(\n    target: ProxyTarget,\n    methodName: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    Object.defineProperty(target.cache, methodName, descriptor);\n    return true;\n  },\n  deleteProperty(target: ProxyTarget, methodName: string) {\n    delete target.cache[methodName];\n    return true;\n  },\n  ownKeys({ scope }: ProxyTarget) {\n    return [...endpointMethodsMap.get(scope).keys()];\n  },\n  set(target: ProxyTarget, methodName: string, value: any) {\n    return (target.cache[methodName] = value);\n  },\n  get({ octokit, scope, cache }: ProxyTarget, methodName: string) {\n    if (cache[methodName]) {\n      return cache[methodName];\n    }\n\n    const method = endpointMethodsMap.get(scope).get(methodName);\n    if (!method) {\n      return undefined;\n    }\n\n    const { endpointDefaults, decorations } = method;\n\n    if (decorations) {\n      cache[methodName] = decorate(\n        octokit,\n        scope,\n        methodName,\n        endpointDefaults,\n        decorations,\n      );\n    } else {\n      cache[methodName] = octokit.request.defaults(endpointDefaults);\n    }\n\n    return cache[methodName];\n  },\n};\n\nexport function endpointsToMethods(octokit: Octokit): RestEndpointMethods {\n  const newMethods = {} as { [key: string]: object };\n\n  for (const scope of endpointMethodsMap.keys()) {\n    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);\n  }\n\n  return newMethods as RestEndpointMethods;\n}\n\nfunction decorate(\n  octokit: Octokit,\n  scope: string,\n  methodName: string,\n  defaults: EndpointOptions,\n  decorations: EndpointDecorations,\n) {\n  const requestWithDefaults = octokit.request.defaults(defaults);\n\n  /* istanbul ignore next */\n  function withDecorations(\n    ...args: [Route, RequestParameters?] | [EndpointOptions]\n  ) {\n    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n    let options = requestWithDefaults.endpoint.merge(...args);\n\n    // There are currently no other decorations than `.mapToData`\n    if (decorations.mapToData) {\n      options = Object.assign({}, options, {\n        data: options[decorations.mapToData],\n        [decorations.mapToData]: undefined,\n      });\n      return requestWithDefaults(options);\n    }\n\n    if (decorations.renamed) {\n      const [newScope, newMethodName] = decorations.renamed;\n      octokit.log.warn(\n        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`,\n      );\n    }\n    if (decorations.deprecated) {\n      octokit.log.warn(decorations.deprecated);\n    }\n\n    if (decorations.renamedParameters) {\n      // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n      const options = requestWithDefaults.endpoint.merge(...args);\n\n      for (const [name, alias] of Object.entries(\n        decorations.renamedParameters,\n      )) {\n        if (name in options) {\n          octokit.log.warn(\n            `\"${name}\" parameter is deprecated for \"octokit.${scope}.${methodName}()\". Use \"${alias}\" instead`,\n          );\n          if (!(alias in options)) {\n            options[alias] = options[name];\n          }\n          delete options[name];\n        }\n      }\n      return requestWithDefaults(options);\n    }\n\n    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n    return requestWithDefaults(...args);\n  }\n  return Object.assign(withDecorations, requestWithDefaults);\n}\n"],"mappings":"AAEA,OAAOA,SAAA,MAAe;AAetB,MAAMC,kBAAA,GAAqB,mBAAIC,GAAA,CAAI;AACnC,WAAW,CAACC,KAAA,EAAOC,SAAS,KAAKC,MAAA,CAAOC,OAAA,CAAQN,SAAS,GAAG;EAC1D,WAAW,CAACO,UAAA,EAAYC,QAAQ,KAAKH,MAAA,CAAOC,OAAA,CAAQF,SAAS,GAAG;IAC9D,MAAM,CAACK,KAAA,EAAOC,QAAA,EAAUC,WAAW,IAAIH,QAAA;IACvC,MAAM,CAACI,MAAA,EAAQC,GAAG,IAAIJ,KAAA,CAAMK,KAAA,CAAM,GAAG;IACrC,MAAMC,gBAAA,GAAmBV,MAAA,CAAOW,MAAA,CAC9B;MACEJ,MAAA;MACAC;IACF,GACAH,QACF;IAEA,IAAI,CAACT,kBAAA,CAAmBgB,GAAA,CAAId,KAAK,GAAG;MAClCF,kBAAA,CAAmBiB,GAAA,CAAIf,KAAA,EAAO,mBAAID,GAAA,CAAI,CAAC;IACzC;IAEAD,kBAAA,CAAmBkB,GAAA,CAAIhB,KAAK,EAAEe,GAAA,CAAIX,UAAA,EAAY;MAC5CJ,KAAA;MACAI,UAAA;MACAQ,gBAAA;MACAJ;IACF,CAAC;EACH;AACF;AAQA,MAAMS,OAAA,GAAU;EACdH,IAAI;IAAEd;EAAM,GAAgBI,UAAA,EAAoB;IAC9C,OAAON,kBAAA,CAAmBkB,GAAA,CAAIhB,KAAK,EAAEc,GAAA,CAAIV,UAAU;EACrD;EACAc,yBAAyBC,MAAA,EAAqBf,UAAA,EAAoB;IAChE,OAAO;MACLgB,KAAA,EAAO,KAAKJ,GAAA,CAAIG,MAAA,EAAQf,UAAU;MAAA;MAClCiB,YAAA,EAAc;MACdC,QAAA,EAAU;MACVC,UAAA,EAAY;IACd;EACF;EACAC,eACEL,MAAA,EACAf,UAAA,EACAqB,UAAA,EACA;IACAvB,MAAA,CAAOsB,cAAA,CAAeL,MAAA,CAAOO,KAAA,EAAOtB,UAAA,EAAYqB,UAAU;IAC1D,OAAO;EACT;EACAE,eAAeR,MAAA,EAAqBf,UAAA,EAAoB;IACtD,OAAOe,MAAA,CAAOO,KAAA,CAAMtB,UAAU;IAC9B,OAAO;EACT;EACAwB,QAAQ;IAAE5B;EAAM,GAAgB;IAC9B,OAAO,CAAC,GAAGF,kBAAA,CAAmBkB,GAAA,CAAIhB,KAAK,EAAE6B,IAAA,CAAK,CAAC;EACjD;EACAd,IAAII,MAAA,EAAqBf,UAAA,EAAoBgB,KAAA,EAAY;IACvD,OAAQD,MAAA,CAAOO,KAAA,CAAMtB,UAAU,IAAIgB,KAAA;EACrC;EACAJ,IAAI;IAAEc,OAAA;IAAS9B,KAAA;IAAO0B;EAAM,GAAgBtB,UAAA,EAAoB;IAC9D,IAAIsB,KAAA,CAAMtB,UAAU,GAAG;MACrB,OAAOsB,KAAA,CAAMtB,UAAU;IACzB;IAEA,MAAMK,MAAA,GAASX,kBAAA,CAAmBkB,GAAA,CAAIhB,KAAK,EAAEgB,GAAA,CAAIZ,UAAU;IAC3D,IAAI,CAACK,MAAA,EAAQ;MACX,OAAO;IACT;IAEA,MAAM;MAAEG,gBAAA;MAAkBJ;IAAY,IAAIC,MAAA;IAE1C,IAAID,WAAA,EAAa;MACfkB,KAAA,CAAMtB,UAAU,IAAI2B,QAAA,CAClBD,OAAA,EACA9B,KAAA,EACAI,UAAA,EACAQ,gBAAA,EACAJ,WACF;IACF,OAAO;MACLkB,KAAA,CAAMtB,UAAU,IAAI0B,OAAA,CAAQE,OAAA,CAAQzB,QAAA,CAASK,gBAAgB;IAC/D;IAEA,OAAOc,KAAA,CAAMtB,UAAU;EACzB;AACF;AAEO,SAAS6B,mBAAmBH,OAAA,EAAuC;EACxE,MAAMI,UAAA,GAAa,CAAC;EAEpB,WAAWlC,KAAA,IAASF,kBAAA,CAAmB+B,IAAA,CAAK,GAAG;IAC7CK,UAAA,CAAWlC,KAAK,IAAI,IAAImC,KAAA,CAAM;MAAEL,OAAA;MAAS9B,KAAA;MAAO0B,KAAA,EAAO,CAAC;IAAE,GAAGT,OAAO;EACtE;EAEA,OAAOiB,UAAA;AACT;AAEA,SAASH,SACPD,OAAA,EACA9B,KAAA,EACAI,UAAA,EACAG,QAAA,EACAC,WAAA,EACA;EACA,MAAM4B,mBAAA,GAAsBN,OAAA,CAAQE,OAAA,CAAQzB,QAAA,CAASA,QAAQ;EAG7D,SAAS8B,gBAAA,GACJC,IAAA,EACH;IAEA,IAAIC,OAAA,GAAUH,mBAAA,CAAoB/B,QAAA,CAASmC,KAAA,CAAM,GAAGF,IAAI;IAGxD,IAAI9B,WAAA,CAAYiC,SAAA,EAAW;MACzBF,OAAA,GAAUrC,MAAA,CAAOW,MAAA,CAAO,CAAC,GAAG0B,OAAA,EAAS;QACnCG,IAAA,EAAMH,OAAA,CAAQ/B,WAAA,CAAYiC,SAAS;QACnC,CAACjC,WAAA,CAAYiC,SAAS,GAAG;MAC3B,CAAC;MACD,OAAOL,mBAAA,CAAoBG,OAAO;IACpC;IAEA,IAAI/B,WAAA,CAAYmC,OAAA,EAAS;MACvB,MAAM,CAACC,QAAA,EAAUC,aAAa,IAAIrC,WAAA,CAAYmC,OAAA;MAC9Cb,OAAA,CAAQgB,GAAA,CAAIC,IAAA,CACV,WAAW/C,KAAK,IAAII,UAAU,kCAAkCwC,QAAQ,IAAIC,aAAa,IAC3F;IACF;IACA,IAAIrC,WAAA,CAAYwC,UAAA,EAAY;MAC1BlB,OAAA,CAAQgB,GAAA,CAAIC,IAAA,CAAKvC,WAAA,CAAYwC,UAAU;IACzC;IAEA,IAAIxC,WAAA,CAAYyC,iBAAA,EAAmB;MAEjC,MAAMC,QAAA,GAAUd,mBAAA,CAAoB/B,QAAA,CAASmC,KAAA,CAAM,GAAGF,IAAI;MAE1D,WAAW,CAACa,IAAA,EAAMC,KAAK,KAAKlD,MAAA,CAAOC,OAAA,CACjCK,WAAA,CAAYyC,iBACd,GAAG;QACD,IAAIE,IAAA,IAAQD,QAAA,EAAS;UACnBpB,OAAA,CAAQgB,GAAA,CAAIC,IAAA,CACV,IAAII,IAAI,0CAA0CnD,KAAK,IAAII,UAAU,aAAagD,KAAK,WACzF;UACA,IAAI,EAAEA,KAAA,IAASF,QAAA,GAAU;YACvBA,QAAA,CAAQE,KAAK,IAAIF,QAAA,CAAQC,IAAI;UAC/B;UACA,OAAOD,QAAA,CAAQC,IAAI;QACrB;MACF;MACA,OAAOf,mBAAA,CAAoBc,QAAO;IACpC;IAGA,OAAOd,mBAAA,CAAoB,GAAGE,IAAI;EACpC;EACA,OAAOpC,MAAA,CAAOW,MAAA,CAAOwB,eAAA,EAAiBD,mBAAmB;AAC3D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}